


      /*  ФАЙЛ    TYPET.H               */

      /* ФАЙЛ ВНЕШНИХ ПЕРЕМЕННЫХ */


#define TOUT		/* Открытие и закрытие файла t.out		*/
#include <stdio.h>

#define maxint 	   32767/* максимальное целое значение ( при переносе 	*/
	/* на asm изменить! )					*/
#define SET_SIZE   8	/* количество слов для хранения битовой строки 	*/
	/* 				*/
#define LATDIF     32	/* разность между кодами соответствующих строч- */
	/* ной и заглавной латинскими буквами в кодировке ASCII		*/
#define RUSDIF1    32	/* */
#define RUSDIF2    80   /* */
#define WORDLENGTH 32	/* длина минимальной адресуемой информационной 	*/
	/* единицы в битах		*/
#define STR_LENGTH 4	/* длина минимальной адресуемой информационной 	*/
	/* единицы в байтах		*/
#define INT_LENGTH 4	/* длина минимальной адресуемой информационной 	*/
	/* единицы в байтах		*/
#define BOOL_LENGTH 4	/* длина минимальной адресуемой информационной 	*/
	/* единицы в байтах		*/
#define MAXORDER   308	/* максимальный допустимый порядок вещественной */
	/* константы с нормализованной мантиссой 					*/
#define labelquality 2
#include "IODEFS.h"
#include "ERR.h"


      extern   struct  textposition   positionnow,/* позиция текущей литеры */
					 /* 1-е описание - в файле "main.c" */
				      token,     /* позиция текущей лексемы */
					 /* 1-е описание - в файле "main.c" */
				      next;    /* позиция следующей лексемы */
					 /* 1-е описание - в файле "main.c" */
      extern   char    name[79];                                     /* имя */
					 /* 1-е описание - в файле "main.c" */
      extern   int     nmbi;                    /* значение целой константы */
					 /* 1-е описание - в файле "main.c" */
      extern   double  nmbf;             /* значение вещественной константы */
					 /* 1-е описание - в файле "main.c" */
      extern   int     onesymbol;          /* значение символьной константы */
					 /* 1-е описание - в файле "main.c" */
      extern   char    strings[MAXLEN];     /* значение строковой константы */
					 /* 1-е описание - в файле "main.c" */
      extern   int     ch;                    /* текущая сканируемая литера */
					 /* 1-е описание - в файле "main.c" */
      extern   char   *addrname;     /* адрес текущего имени в таблице имен */
				     /* 1-е описание - в файле "rumtabl3.c" */
      extern   unsigned          errorcode;                   /* код ошибки */
					 /* 1-е описание - в файле "main.c" */
      extern   unsigned          symbol;             /* код текущей лексемы */
					 /* 1-е описание - в файле "main.c" */
      extern   unsigned          hashresult;  /* результат hash-функции для */
							  /* текущего имени */
				     /* 1-е описание - в файле "rumtabl3.c" */
      extern   unsigned          nextsymbol;       /* код следующей лексемы */
					 /* 1-е описание - в файле "main.c" */
      extern   unsigned short    cnt;                        /* для отладки */
					 /* 1-е описание - в файле "main.c" */
      extern   unsigned short    lname;
				/* длина идентификатора или ключевого слова */
					 /* 1-е описание - в файле "main.c" */
      extern   FILE 	    	*t,     
				*mesfile,
				*dstfile,
				*srcfile;

      extern   char  		 line[ MAXLEN ],
				*messages[ MAXMES ],
				 sfile[ FNAME ],
				 dfile[ FNAME ];

      extern   short 		 LastInLine,   /* значащие символы в строке */
				 ErrInx, /* число сделанных в строке ошибок */
				 ErrorOverflow,/* TRUE-слишком много ошибок,*/
							 /* FALSE-нормально */
				 ErrorCount; /* число сделанных в программе */
								  /* ошибок */

      extern   struct E 	 Errlist[ ERRMAX ];        /* список ошибок */

      extern   struct textposition positionnow;
      extern
	   int labeltable[labelquality],
	       meetlabel[labelquality],
	       meetgoto[labelquality],g_coun;



/* Описание реализуемых в виде битовых строк множеств символов, 	*/
/* стартовых для различных обрабатываемых конструкций:			*/
/* первое описание - в файле main.c					*/

extern unsigned

*idstarters,		/* стартовый символ ident			*/
*begpart,		/* стартовые символы функции block()		*/
*rpar,			/* ... правая скобка 				*/
*st_constpart,		/* стартовые символы функции constpart()	*/
*st_typepart,		/* стартовые символы функции typepart()		*/
*st_varpart,		/* стартовые символы функции varpart()		*/
*st_procfuncpart,	/* стартовые символы функции procfuncpart()	*/
*st_statpart,		/* стартовые символы функции statpart()		*/
*st_constant,	 	/* стартовые символы функции constant()		*/
*st_conaftersign,	/* стартовые символы конструкции константы, 	*/
	/* идущей после знака + или -					*/
*st_typ,		/* стартовые символы функции typ()		*/
*st_typafterpack,	/* стартовые символы конструкции описания типа 	*/
	/* после ключевого слова packedsy				*/
*st_simpletype,	/* стартовые символы функции simpletype()	*/
*st_fixpart,           /* стартовые символы функции fixpart()	и	*/
	/* функции reestrfields()					*/
*st_casefield,         /* стартовые символы функции casefield()	*/
*st_statement,          /* стартовые символы конструкции <оператор>     */
*st_startstatement,     /* стартовые символы оператора при нейтрализации*/
*st_variant,            /* стартовые символы конструкции <вариант> в    */
	 /* операторе варианта                                          */
*st_express,		/* ... выражения 				*/
*st_termfact;		/* ... слагаемого и множителя 			*/

/* Описание реализуемых в виде битовых строк множеств символов, 	*/
/* ожидаемых сразу после обработки различных конструкций:		*/
/* первое описание - в файле main.c					*/

extern unsigned

*blockfol,		/* ...после обработки блока основной программы  */
*af_1constant,		/* ...после обработки константы при вызове	*/
	/* constant() из constdeclaration(), а также после обработки 	*/
	/* объявления типа при вызове vardeclaration() из varpart()	*/
*af_2constant,		/* ...после анализа константы при вызове функ-	*/
	/* ции constant() из функции casefield()			*/
*af_3const1,		/* ...после анализа первой константы отрезка	*/
	/* при обработке оного в функции simpletype()			*/
*af_4const2,		/* ...после анализа второй константы отрезка	*/
	/* при обработке оного в функции simpletype()			*/
*af_simpletype,		/* ...после анализа конструкции типа индекса во */
	/* время обработки типа массива					*/
*af_1typ,		/* ...после анализа конструкции описания типа	*/
	/* при вызове функции typ() из typedeclaration()		*/
*af_2typ,		/* ...после анализа конструкции описания типа	*/
	/* при вызове функции typ() из fixpart()			*/
*af_1reestrfields,	/* ...после анализа конструкции списка полей 	*/
	/* при вызове функции reestrfields() из функции complextype()	*/
*af_2reestrfields,	/* ...после анализа конструкции списка полей,	*/
	/* вложенного внутри записи, т.е. при вызове reestrfields() из	*/
	/* casefield()							*/
*af_fixpart,		/* ...после анализа фиксированной части списка 	*/
	/* полей 							*/
*af_proclistparam,      /* ...после анализа списка параметров процедуры */
*af_funclistparam,      /* ...после анализа списка параметров функции   */
*af_blockprocfunc,      /* ...после анализа блока процедуры или функции */
*af_sameparam,          /* ...после анализа однотипных параметров       */
*af_factparam,          /* ...после анализа фактических параметров      */
	/* процедур и функций                                           */
*af_oneparam,           /* ...после анализа параметра стандартных       */
	/* процедур и функций, имеющих один параметр                    */
*af_writeparam,         /* ...после анализа параметра стандартных       */
	/* процедур write и writeln                                     */
*af_assignment,         /* ...после анализа переменной в операторе      */
	/* присваивания							*/
*af_compstatement,      /* ...после анализа оператора в составном оп-ре */
*af_iftrue,             /* ...после анализа условного выражения в опера-*/
	/*торе if							*/
*af_iffalse,            /* ...после анализа оператора ветви "истина" в  */
	/* операторе if							*/
*af_whilefor,		/* ...после анализа условного выражения в опера-*/
	/* торе while и выражения-второй границы изменения параметра    */
	/* цикла в операторе for					*/
*af_repeat,             /* ...после анализа оператора в теле цикла repeat*/
*af_with,               /* ...после анализа  переменной  в   заголовке  */
	/* оператора with						*/
*af_case1,              /* ...после анализа выбирающего выражения в case*/
*af_case2,              /* ...после анализа варианта в операторе case   */
*af_forassign,	        /* ...после анализа переменной в операторе for	*/
*af_for1, 		/* ...после анализа выражения-первой границы из-*/
	/* менения параметра цикла в операторе for			*/
*af_ident,		/* ...после идентификатора в "переменной"	*/
*af_index,		/* ...после индекса при разборе массива		*/
*af_set1,		/* ...после 1-го выражения в конструкторе множ. */
*af_label,              /* ... после константы в разделе описания меток*/
*af_label1,             /* ... после раздела описания меток */
*af_goto;               /* ... после goto                                */
/**af_var1; */               /* ... после раздела описания переменных*/

/* Описание реализуемых в виде битовых строк множеств допустимых симво- */
/* лов операций в разделе компиляции выражений 				*/

extern unsigned

*op_rel,		/* операции отношения над простыми выражениями	*/
*op_add,		/* аддитивные операции над слагаемыми		*/
*op_mult;		/* мультипликативные операции над множителями	*/

/* Описание реализуемых в виде битовых строк множеств способов исполь-	*/
/* зования идентификаторов:						*/
/* первое описание - в файле main.c					*/

extern unsigned

*set_VARCONFUNCS,	/* доп. способы использования - VARS, CONSTS, FUNCS */
*set_VARS,	/* допустимый способ использования - VARS		*/
*set_TYPES, 	/* допустимый способ использования - TYPES 		*/
*set_CONSTS,	/* допустимый способ использования - CONSTS 		*/
*set_TYCON,     /* допустимые способы использования - TYPES,CONSTS	*/
*set_FUNCS,     /* допустимый способ использования - FUNCS              */
*set_PROCS,     /* допустимый способ использования - PROCS              */
*set_FUNPR,     /* допустимые способы использования - FUNCS,PROCS       */
*set_VARFUNPR;  /* допустимые способы использования - VARS,FUNCS,PROCS  */

/* Описание реализуемого в виде битовой строки множества кодов типов,	*/
/* недопустимых для использования в том или ином контексте:		*/
/* первое описание - в файле main.c					*/


