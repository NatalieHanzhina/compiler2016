# compiler2016
Компилятор на C в ассемблер NASM.
Реализованы лексический, синтаксический, семантический  анализ, генерация кода.

В файле Nextch.c содержится модуль ввода-вывода.

В файле NEXTSYM4.C - основная логика лексического анализа.

В файле LAST.C - основная логика синтаксического, семантического анализа и генерация кода.

ERROR.C - занесение cведений об ошибке в список ошибок.

HASH.C - хэш-функция для таблицы имен.

LITFUNCS.C - функции для работы с битовыми множествами, которыми реализованы множества FOLLOW (в том числе проверка принадлежности множеству, объединение множеств, ). Реализует проверку совпадения сканируемого токена и ожидаемого. Реализует режим паники (пропуск токенов до первого "знакомого" при несовпадении текущего токена с ожидаемым).

RUMTABL3.C - работа с таблицей имен. Реализованы занесение в таблицу имен на основе хэша, поиск в таблице имен.

DECKEY.H - коды ключевых слов языка.

DECW.H - коды токенов-разделителей, констант, вспомогательных констант.

ERR.H - структура данных об  ошибках для анализатора.

FUNCS.H - объявление функций.

IODEFS.H - константы для блока ввода-вывода.

RUMERCOD.h - коды ошибок для анализа.

TEXTP.H  - структуры для позиции текущего токена во входном потоке.

TREE.H - константы для типов идентификаторов для анализа.

TYPES.H - объявление кодов базовых типов.

TYPET.h - объявление внешних переменных.
# Build 
gcc Main.c -o main

# Run
./main nod.pas nod.lst

В случае отсутствия ошибок компиляции выходных файла будет два: листинг (.lst) и .asm

nasm -f elf -l output.lst output.asm

gcc -m32 -o prog output.o

./prog

# I/O Examples
Примеры входных файлов в репозитории: 

prog - с ошибками, 

prog_r - без ошибок.

prog_s.pas - без ошибок,

prog_exp - без ошибок, содержит выражение,

nod.pas - без ошибок, алгоритм Евклида вычисления НОД двух чисел.

Выходные: 

prog.lst, 

prog_r.lst,

prog_s.lst
соответственно первым трем программам, 

output.asm - ассемблерный код для prog_s.pas,

output_exp.asm - ассемблерный код для prog_exp,

output_nod.asm - ассемблерный код для nod.pas
# Lang
Язык pascal-подобный, поддерживает:

целый, логический типы, 

раздел переменных,

раздел функций, процедур,

передачу в функции параметров по значению.

операцию присваивания,

операции сложения, вычитания, деления нацело и с остатком, сравнения, логического И, ИЛИ, НЕ,

выражения со скобками,

вызов функций, процедур,

функции ввода/вывода (read, readln, write, writeln)

пустой оператор,

условный оператор (полный и сокращенный),

циклы с предусловием (while do) и с постусловием (repeat until),

простой и составной операторы,

комментарии.


Язык следующий:

<программа> ::= program <имя> (<имя файла> {, <имя файла>}); <блок>.

<имя файла> ::= <имя>

<имя> ::= <буква> {<буква> | <цифра>}

<блок> ::= <раздел переменных> <раздел процедур и функций> <раздел операторов>

<определение константы> ::= <имя> = <константа>

<константа> ::= <число без знака> | <знак> <число без знака> | <имя константы> | <знак> <имя константы> | <строка>

<число без знака> ::= <целое без знака>

<целое без знака> ::= <цифра> {<цифра>}

<знак> ::= + | - 

<имя константы> ::= <имя>

<строка> ::= ‘<символ> {<символ>}’

<тип> ::= <простой тип> | <составной тип> 

<простой тип> ::= <перечислимый тип> | <ограниченный тип> | <имя типа>

<перечислимый тип> ::=(<имя> {, <имя>})

<ограниченный тип> ::= <константа> .. <константа>

<имя типа> ::= <имя>

<составной тип> ::= <регулярный тип>  

<регулярный тип> ::= array [<простой тип > {, < простой тип >}] of <тип компоненты >

<тип компоненты>::=<тип >

<базовый тип> ::= <простой тип>

<раздел переменных> ::= var <описание однотипных переменных> ;
                                                    {<описание однотипных переменных>;} | <пусто> 
                                                    
<описание однотипных переменных> ::= <имя> {, <имя>} : <тип>

<раздел процедур и функций> ::= {<описание процедуры или функции> ;}

<описание процедуры или функции> ::= <описание процедуры> | <описание функции>

<описание процедуры> ::= <заголовок процедуры> <блок>

<заголовок процедуры> ::= procedure <имя> ; | procedure <имя> (<раздел формальных параметров> {; <раздел формальных параметров>}) ;

<раздел формальных параметров> ::= <группа параметров> | var <группа параметров> | function <группа параметров> | procedure <имя> {, <имя>}

<группа параметров> ::= <имя> {, <имя>} : <имя типа>

<описание функции> ::= <заголовок функции> <блок>

<заголовок функции> ::= function <имя> : <тип результата> ; | function <имя> (<раздел формальных параметров> {; <раздел формальных параметров>}) : <тип результата> ;

<тип результата> ::= <имя типа>

<раздел операторов> ::= <составной оператор>

<оператор> ::= <простой оператор> | <сложный оператор>

<простой оператор> ::= <оператор присваивания> | <оператор процедуры>  | <пустой оператор>

<оператор присваивания> ::= <переменная> := <выражение> | <имя функции> := <выражение>

<переменная> ::= <полная переменная> | <компонента переменной> 

<полная переменная> ::= <имя переменной>

<имя переменной> ::= <имя>

<компонента переменной> ::= <индексированная переменная>

<индексированная переменная> ::= <переменная-массив> [<выражение> {, <выражение>}]

<переменная-массив> ::= <переменная>

<выражение> ::= <простое выражение> | <простое выражение> <операция отношения><простое выражение>

<операция отношения> ::= = | <> | < | <= | >= | > 

<простое выражение> ::=  <знак> <слагаемое> { <аддитивная операция> <слагаемое>}

<аддитивная операция> ::= + | - | or

<слагаемое> ::= <множитель> { <мультипликативная операция> <множитель>}

<мультипликативная операция> ::= * | / | mod | and

<множитель> ::= <переменная> | <константа без знака> | (<выражение>) | <обозначение функции> | not <множитель>

<константа без знака> ::= <число без знака> | <строка> | <имя константы> | nil

<обозначение функции> ::= <имя функции> |
                                      <имя функции> (<фактический параметр> {, <фактический параметр>})
<имя функции> ::= <имя>

<оператор процедуры> ::= <имя процедуры> | 
                                   <имя процедуры> (<фактический параметр> {, <фактический параметр>})
                                   
<имя процедуры> ::= <имя>

<фактический параметр> ::= <выражение> | <переменная> | <имя процедуры> | <имя функции>

<пустой оператор> ::= <пусто>

<пусто> ::=

<сложный оператор> ::= <составной оператор> | <выбирающий оператор> | <оператор цикла> | <оператор присоединения>

<составной оператор> ::=  begin <оператор> {; <оператор>} end

<выбирающий оператор> ::= <условный оператор> 

<условный оператор> ::= if <выражение> then <оператор> | if <выражение> then <оператор> else <оператор>

<оператор цикла> ::= <цикл с предусловием> | <цикл с постусловием> | <цикл с параметром>

<цикл с предусловием> ::= while <выражение> do <оператор>

<цикл с постусловием> ::= repeat <оператор> {; <оператор>} until <выражение>

<цикл с параметром> ::= for <параметр цикла > := <выражение> 
                                               <направление>  <выражение> do  <оператор>     
                                               
<параметр цикла >:= <имя>  

<направление> ::= to | downto    

