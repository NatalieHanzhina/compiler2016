# compiler2016
Компилятор на C в ассемблер NASM.
Реализованы лексический, синтаксический, семантический  анализ, генерация кода.

1. В файле Nextch.c содержится модуль ввода-вывода.

2. В файле NEXTSYM4.C - основная логика лексического анализа.

3. В файле LAST.C - основная логика синтаксического, семантического анализа и генерация кода.

4. ERROR.C - занесение cведений об ошибке в список ошибок.

5. HASH.C - хэш-функция для таблицы имен.

6. LITFUNCS.C - функции для работы с битовыми множествами, которыми реализованы множества FOLLOW (в том числе проверка принадлежности множеству, объединение множеств, ). Реализует проверку совпадения сканируемого токена и ожидаемого. Реализует режим паники (пропуск токенов до первого "знакомого" при несовпадении текущего токена с ожидаемым).

7. RUMTABL3.C - работа с таблицей имен. Реализованы занесение в таблицу имен на основе хэша, поиск в таблице имен.

8. DECKEY.H - коды ключевых слов языка.

9. DECW.H - коды токенов-разделителей, констант, вспомогательных констант.

10. ERR.H - структура данных об  ошибках для анализатора.

11. FUNCS.H - объявление функций.

12. IODEFS.H - константы для блока ввода-вывода.

13. RUMERCOD.h - коды ошибок для анализа.

14. TEXTP.H  - структуры для позиции текущего токена во входном потоке.

15. TREE.H - константы для типов идентификаторов для анализа.

16. TYPES.H - объявление кодов базовых типов.

17. TYPET.h - объявление внешних переменных.

# Run tests
make -i -f makefile 

# I/O Examples
Примеры входных файлов в репозитории: 

prog_err - с ошибками, 

prog_r - без ошибок.

prog_s.pas - без ошибок,

prog_exp - без ошибок, содержит выражение,

nod.pas - без ошибок, алгоритм Евклида вычисления НОД двух чисел.

Выходные: 

prog_err.lst, 

prog_r.lst,

prog_s.lst
соответственно первым трем программам, 

output.asm - ассемблерный код для prog_s.pas,

output_exp.asm - ассемблерный код для prog_exp,

output_nod.asm - ассемблерный код для nod.pas
# Lang
Язык pascal-подобный, поддерживает:

1. целый, логический типы, 

2. раздел переменных,

3. раздел функций, процедур,

4. передачу в функции параметров по значению.

5. операцию присваивания,

6. операции сложения, вычитания, деления нацело и с остатком, сравнения, логического И, ИЛИ, НЕ,

7. выражения со скобками,

8. вызов функций, процедур,

9. функции ввода/вывода (read, readln, write, writeln)

10. пустой оператор,

11. условный оператор (полный и сокращенный),

12. циклы с предусловием (while do) и с постусловием (repeat until),

13. простой и составной операторы,

14. комментарии.


## Язык следующий:

<программа> ::= **program** <имя> (<имя файла> {, <имя файла>}); <блок>.

<имя файла> ::= <имя>

<имя> ::= <буква> {<буква> | <цифра>}

<блок> ::= <раздел переменных> <раздел процедур и функций> <раздел операторов>

<определение константы> ::= <имя> = <константа>

<константа> ::= <число без знака> | <знак> <число без знака> | <имя константы> | <знак> <имя константы> | <строка>

<число без знака> ::= <целое без знака>

<целое без знака> ::= <цифра> {<цифра>}

<знак> ::= + | - 

<имя константы> ::= <имя>

<строка> ::= ‘<символ> {<символ>}’

<тип> ::= <простой тип> | <составной тип> 

<простой тип> ::= <перечислимый тип> | <ограниченный тип> | <имя типа>

<перечислимый тип> ::=(<имя> {, <имя>})

<ограниченный тип> ::= <константа> .. <константа>

<имя типа> ::= <имя>

<составной тип> ::= <регулярный тип>  

<регулярный тип> ::= **array** [<простой тип > {, < простой тип >}] **of** <тип компоненты >

<тип компоненты> ::= <тип >

<базовый тип> ::= <простой тип>

<раздел переменных> ::= **var** <описание однотипных переменных> ;
                                                    {<описание однотипных переменных>;} | <пусто> 
                                                    
<описание однотипных переменных> ::= <имя> {, <имя>} : <тип>

<раздел процедур и функций> ::= {<описание процедуры или функции> ;}

<описание процедуры или функции> ::= <описание процедуры> | <описание функции>

<описание процедуры> ::= <заголовок процедуры> <блок>

<заголовок процедуры> ::= **procedure** <имя> ; | **procedure** <имя> (<раздел формальных параметров> {; <раздел формальных параметров>}) ;

<раздел формальных параметров> ::= <группа параметров> | **var** <группа параметров> | **function** <группа параметров> | **procedure** <имя> {, <имя>}

<группа параметров> ::= <имя> {, <имя>} : <имя типа>

<описание функции> ::= <заголовок функции> <блок>

<заголовок функции> ::= **function** <имя> : <тип результата> ; | **function** <имя> (<раздел формальных параметров> {; <раздел формальных параметров>}) : <тип результата> ;

<тип результата> ::= <имя типа>

<раздел операторов> ::= <составной оператор>

<оператор> ::= <простой оператор> | <сложный оператор>

<простой оператор> ::= <оператор присваивания> | <оператор процедуры>  | <пустой оператор>

<оператор присваивания> ::= <переменная> := <выражение> | <имя функции> := <выражение>

<переменная> ::= <полная переменная> | <компонента переменной> 

<полная переменная> ::= <имя переменной>

<имя переменной> ::= <имя>

<компонента переменной> ::= <индексированная переменная>

<индексированная переменная> ::= <переменная-массив> [<выражение> {, <выражение>}]

<переменная-массив> ::= <переменная>

<выражение> ::= <простое выражение> | <простое выражение> <операция отношения><простое выражение>

<операция отношения> ::= = | <> | < | <= | >= | > 

<простое выражение> ::=  <знак> <слагаемое> { <аддитивная операция> <слагаемое>}

<аддитивная операция> ::= + | - | **or**

<слагаемое> ::= <множитель> { <мультипликативная операция> <множитель>}

<мультипликативная операция> ::= * | / | **mod** | **and**

<множитель> ::= <переменная> | <константа без знака> | (<выражение>) | <обозначение функции> | not <множитель>

<константа без знака> ::= <число без знака> | <строка> | <имя константы> | **nil**

<обозначение функции> ::= <имя функции> |
                                      <имя функции> (<фактический параметр> {, <фактический параметр>})
<имя функции> ::= <имя>

<оператор процедуры> ::= <имя процедуры> | 
                                   <имя процедуры> (<фактический параметр> {, <фактический параметр>})
                                   
<имя процедуры> ::= <имя>

<фактический параметр> ::= <выражение> | <переменная> | <имя процедуры> | <имя функции>

<пустой оператор> ::= <пусто>

<пусто> ::=

<сложный оператор> ::= <составной оператор> | <выбирающий оператор> | <оператор цикла> | <оператор присоединения>

<составной оператор> ::=  **begin** <оператор> {; <оператор>} **end**

<выбирающий оператор> ::= <условный оператор> 

<условный оператор> ::= **if** <выражение> then <оператор> | **if** <выражение> **then** <оператор> **else** <оператор>

<оператор цикла> ::= <цикл с предусловием> | <цикл с постусловием> | <цикл с параметром>

<цикл с предусловием> ::= **while** <выражение> **do** <оператор>

<цикл с постусловием> ::= **repeat** <оператор> {; <оператор>} **until** <выражение>

<цикл с параметром> ::= **for** <параметр цикла > := <выражение> 
                                               <направление>  <выражение> do  <оператор>     
                                               
<параметр цикла >:= <имя>  

<направление> ::= **to** | **downto**  

